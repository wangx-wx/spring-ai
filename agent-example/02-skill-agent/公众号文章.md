# 基于 Spring AI Alibaba 打造可扩展的 AI 技能代理系统

> 本文介绍如何使用 Spring AI Alibaba 的 ReactAgent 框架，结合 ModelInterceptor 实现一个支持"渐进式"加载的技能系统，让你的 AI 代理具备无限扩展的能力。

## 前言

在构建 AI 应用时，我们常常面临一个矛盾：

- **上下文窗口是有限的** —— 不可能把所有知识都塞进系统提示词
- **用户需求是多样的** —— 需要 AI 具备各种领域的专业能力

如何让 AI 代理"按需加载"专业知识，而不是一股脑全部载入？

今天分享一个基于 **Spring AI Alibaba** 的解决方案：**技能代理系统（Skill Agent）**。

## 什么是 ReactAgent？

Spring AI Alibaba 提供的 `ReactAgent` 是一个基于 ReAct（Reasoning + Acting）模式的智能代理框架。

ReAct 模式的核心思想是：**让 AI 在推理的同时采取行动，根据行动结果继续推理，形成闭环**。

```
用户请求 → 思考(Thought) → 行动(Action) → 观察(Observation) → 思考 → ... → 最终答案
```

### ReactAgent 的优势

**1. 开箱即用的工具集成**

```java
List<ToolCallback> tools = new ArrayList<>();
tools.add(ReadFileTool.createReadFileToolCallback(ReadFileTool.DESCRIPTION));
tools.add(WriteFileTool.createWriteFileToolCallback(WriteFileTool.DESCRIPTION));
tools.add(ShellTool.builder(System.getProperty("user.dir")).build());
```

**2. 灵活的拦截器机制**

```java
ReactAgent.builder()
    .name("skill-agent")
    .model(chatModel)
    .interceptors(customInterceptor)  // 自定义拦截器
    .tools(tools)
    .build();
```

**3. 内置的安全钩子**

```java
ShellToolAgentHook hook = ShellToolAgentHook.builder()
    .shellToolName("shell")
    .build();
```

## 核心设计：渐进式技能加载

### 问题：上下文膨胀

假设我们有 20 个技能，每个技能的详细说明有 500 tokens，全部加载就是 10000 tokens。这还没算用户的对话历史！

### 解决方案：三层渐进式加载

```
┌─────────────────────────────────────────────────────────┐
│  第一层：元数据（始终加载）                                │
│  - 技能名称 + 简短描述                                    │
│  - 约 100 tokens / 技能                                  │
└─────────────────────────────────────────────────────────┘
                          ↓ 匹配到技能时
┌─────────────────────────────────────────────────────────┐
│  第二层：SKILL.md 正文（按需加载）                         │
│  - 详细使用说明和工作流程                                  │
│  - 约 500-2000 tokens / 技能                            │
└─────────────────────────────────────────────────────────┘
                          ↓ 需要时
┌─────────────────────────────────────────────────────────┐
│  第三层：辅助资源（按需加载）                               │
│  - 脚本、参考文档、模板                                    │
│  - 无上限（可执行而不加载到上下文）                          │
└─────────────────────────────────────────────────────────┘
```

**关键洞察**：第一层元数据始终在上下文中，AI 据此判断使用哪个技能；只有当 AI 决定使用某个技能时，才通过 `read_file` 工具加载第二、三层内容。

## 实现：ModelInterceptor 的妙用

`ModelInterceptor` 是 ReactAgent 提供的模型拦截器，可以在每次调用大模型前后进行处理。

### 定义拦截器

```java
@Slf4j
public class SkillsInterceptor extends ModelInterceptor {

    private final SkillRegistry skillRegistry;
    private volatile boolean skillsLoaded = false;

    @Override
    public ModelResponse interceptModel(ModelRequest request, ModelCallHandler handler) {
        // 延迟加载技能
        if (!skillsLoaded) {
            synchronized (this) {
                if (!skillsLoaded) {
                    loadSkills();
                }
            }
        }

        // 构建技能提示词（只包含元数据）
        List<SkillMetadata> skills = skillRegistry.listAll();
        if (skills.isEmpty()) {
            return handler.call(request);
        }

        String skillsPrompt = buildSkillsPrompt(skills);

        // 增强系统消息
        SystemMessage enhanced = enhanceSystemMessage(
            request.getSystemMessage(),
            skillsPrompt
        );

        ModelRequest modified = ModelRequest.builder(request)
            .systemMessage(enhanced)
            .build();

        return handler.call(modified);
    }

    @Override
    public String getName() {
        return "skills";
    }
}
```

### 构建技能提示词

注意：这里只注入技能的 **名称** 和 **描述**，不包含详细内容！

```java
private String buildSkillsPrompt(List<SkillMetadata> skills) {
    StringBuilder sb = new StringBuilder();
    sb.append("""
        ## Skills System
        You have access to a skills library.

        **CRITICAL: Skills are NOT tools!**
        Skills are instruction documents that guide you on how to use your available tools.
        You must first read its SKILL.md file to understand the workflow.

        **Available Skills:**
        """);

    for (SkillMetadata skill : skills) {
        sb.append(String.format("- **%s**: %s\n", skill.getName(), skill.getDescription()));
        sb.append(String.format("  → Read `%s/SKILL.md` to use this skill\n", skill.getSkillPath()));
    }

    sb.append("""

        **How to Use Skills:**
        1. Read the SKILL.md file using read_file tool
        2. Follow the instructions in SKILL.md
        3. Use your available tools as directed
        """);

    return sb.toString();
}
```

### 技能文件结构

每个技能是一个目录，包含 `SKILL.md` 文件：

```
skills/
├── arxiv-search/
│   ├── SKILL.md           # 技能说明（第二层）
│   └── arxiv_search.py    # 辅助脚本（第三层）
└── web-search/
    └── SKILL.md
```

`SKILL.md` 使用 YAML frontmatter 定义元数据：

```markdown
---
name: arxiv-search
description: Search arXiv for academic papers in physics, mathematics, computer science
---

# arXiv Search Skill

## When to Use
Use this skill when you need to find academic papers...

## How to Use
Run the Python script with shell tool:
\```bash
python3 {skill_path}/arxiv_search.py "search query"
\```
```

### 技能扫描器

启动时扫描目录，只解析 frontmatter（元数据）：

```java
@Slf4j
public class SkillScanner {

    private final Yaml yaml = new Yaml();

    public SkillMetadata loadSkill(Path skillDir, String source) {
        Path skillFile = skillDir.resolve("SKILL.md");

        String content = Files.readString(skillFile);
        Map<String, Object> frontmatter = parseFrontmatter(content);

        String name = (String) frontmatter.get("name");
        String description = (String) frontmatter.get("description");

        return SkillMetadata.builder()
            .name(name)
            .description(description)  // 只存描述，不存正文！
            .skillPath(skillDir.toString())
            .source(source)
            .build();
    }

    private Map<String, Object> parseFrontmatter(String content) {
        if (!content.startsWith("---")) {
            return null;
        }
        int endIndex = content.indexOf("---", 3);
        String frontmatterStr = content.substring(3, endIndex).trim();
        return yaml.load(frontmatterStr);
    }
}
```

## 完整工作流程

让我们看一个完整的交互流程：

```
用户: "帮我搜索关于 Transformer 的最新论文"

┌─────────────────────────────────────────────────────────┐
│ 1. SkillsInterceptor 拦截请求                            │
│    注入技能元数据到系统提示词：                             │
│    - arxiv-search: Search arXiv for academic papers...  │
│    - web-search: Conduct comprehensive web research...  │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 2. AI 推理（第一次）                                      │
│    Thought: 用户要搜索论文，arxiv-search 技能适合          │
│    Action: read_file("skills/arxiv-search/SKILL.md")    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 3. AI 获取技能详细说明                                    │
│    Observation: [SKILL.md 的完整内容]                    │
│    学习到需要执行 Python 脚本                              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 4. AI 推理（第二次）                                      │
│    Thought: 按照技能说明，需要执行搜索脚本                   │
│    Action: shell("python3 .../arxiv_search.py 'transformer'")
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 返回结果                                              │
│    Observation: [论文搜索结果]                            │
│    Answer: 为您找到以下关于 Transformer 的论文...          │
└─────────────────────────────────────────────────────────┘
```

**关键点**：SKILL.md 的详细内容只在 AI 决定使用该技能时才加载，而不是一开始就全部塞进上下文！

## 效果对比

| 方案 | 20个技能的上下文占用 | 可扩展性 |
|------|---------------------|----------|
| 全量加载 | ~10000 tokens | 差 |
| 渐进式加载 | ~2000 tokens（元数据） + 按需加载 | 优秀 |

**节省 80% 的上下文空间**，同时保持无限扩展能力！

## 总结

本文介绍了如何基于 Spring AI Alibaba 的 ReactAgent 构建可扩展的技能代理系统：

1. **ReactAgent** 提供了完整的 ReAct 循环实现和丰富的工具集成
2. **ModelInterceptor** 让我们可以在模型调用前注入自定义逻辑
3. **渐进式加载** 通过三层架构（元数据 → 说明文档 → 资源文件）有效管理上下文

这个架构的精妙之处在于：**把 AI 当作一个会查阅手册的专家，而不是一个记住所有知识的百科全书**。

---

**项目地址**：[GitHub 链接]

**相关资源**：
- Spring AI Alibaba 官方文档
- ReactAgent 源码解析

如果觉得有帮助，欢迎点赞、在看、转发三连！
